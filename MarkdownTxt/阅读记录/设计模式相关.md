资料来源： https://www.jdon.com/designpatterns/



​	GOF设计模式分三种类型：结构型、创建型和行为型，这三者类型其实对应着一个系统的三个阶段：设计阶段、创建阶段和运行阶段。

​	结构型模式指出如何设计出系统的结构，也就是一个系统的孕育，如同人的十月怀胎过程。

​	创建型模式指出系统起初如何被创建，也就是宇宙大爆炸前一刻，是系统从纸上落地，如同人的出生和养育，是从无到有的创建过程。

​	行为型模式是针对系统创建后进入自我运行阶段，这时再也无需创建者和设计者干预，如同人的成年结婚生子。也就是宇宙形成后的运行状态。

---

## 一、创建模式

### 1. 工厂模式(Factory Method) 

```java
public class Factory{
　　public static Sample creator(int which){
　　//getClass 产生Sample 一般可使用动态类装载装入类。
　　if (which==1)
　　　　return new SampleA();
　　else if (which==2)
　　　　return new SampleB();
　　}
}
// 使用时如下
Sample sample = Factory.creator(1)
```

​	用于包装同一个类别Sample，Sample有对象SampleA和SampleB...。工厂模式的出现就是为了区别生成基类Sample的concrete对象。

​	在获取sample实例对象过程中，就不涉及到Sample的具体子类，从而达到封装效果，减少错误修改的机会。而类的生成，通过which来区分生成。通过类的种类区分，以前置条件隔离，达到更好的灵活性以及封装效果。

例如：用户等级划分时，用户不同的级别对应了不同的权限以及不同的业务流程。

S——普通客户、S1——初级客户、S2——中级客户、S3——高级客户...

以此类推，通过不同的前置条件*<用户等级>* 来达到不同的用户生成流程，以此来确定不同用户类型、用户权限、用户界面等等。

### 2. 抽象工厂(Abstract Factory)

​	与工厂方法比较，这两个模式区别在于需要创建对象的复杂程度上。如果我们创建对象的方法变得复杂了,如上面工厂方法中是创建一个对象Sample,如果我们还有新的产品接口Sample2。那么，我们就将上例中Factory变成抽象类,将共同部分封装在抽象类中,不同部分使用子类实现，下面就是将上例中的Factory拓展成抽象工厂。

```java
public abstract class Factory{
　　public abstract Sample creator();
　　public abstract Sample2 creator(String name);
}

public class SimpleFactory extends Factory{
　　public Sample creator(){
　　　　.........
　　　　return new SampleA
　　}
　　public Sample2 creator(String name){
　　　　.........
　　　　return new Sample2A
　　}
}

public class BombFactory extends Factory{
　　public Sample creator(){
　　　　......
　　　　return new SampleB 
　　}
　　public Sample2 creator(String name){
　　　　......
　　　　return new Sample2B
　　}
}
```

​	从上例中可见，一个抽象工厂统领了多个抽象工厂，意义何在？因为 SimpleFactory内，生产Sample和生产Sample2的方法之间有一定联系，所以才要将这两个方法捆绑在一个类中，这个工厂类有其本身特征，也许制造过程是统一的，比如：制造工艺比较简单，所以名称叫SimpleFactory。

高级语言中关于工厂模式最常用的一种前置条件配置为：*反射*

```java
className =  "com.jivesoftware.forum.database.DbForumFactory";
//动态转载类
Class c = Class.forName(className);
factory = (ForumFactory)c.newInstance();
```

### 3. 单态模式(Singleton)

​	*Singleton模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。*

​	在很多操作中，比如建立目录 数据库连接都需要这样的单线程操作。

​	Singleton能够被状态化；这样，多个单态类可以组成一个状态仓库对外提供服务。比如，论坛中的帖子计数器，每次浏览需要一次计数，单态类能够保持住这个计数，且可异步操作。如果需要对这个单态下的数据做业务处理，则可以在不修改单态接口的情况下方便的做到。

​	Singleton也可以被无状态化，提供工具性质的功能。

​	Singleton的好处也在于可以节省内存，因为他实际限制了实例的个数，且重复的使用相同的实例提供不同的服务。同样，该类可以和工厂模式结合，达到资源的有效利用。

```java
// 饿汉模式——在类的装载过程中即静态创建实例
public class Singleton {
    private Singleton(){}
	//在自己内部定义自己一个实例。
	//注意这是private 只供内部调用
	private static Singleton instance = new Singleton();
	//这里提供了一个供外部访问本class的静态方法，可以直接访问　　
	public static Singleton getInstance() {
      return instance; 　　
  } 
}
// 懒汉模式——在需要使用的时候再行创建实例
public class Singleton {	//此例为线程安全模式
    private static Singleton instance = null;
    public static synchronized Singleton getInstance() {	// 应对多线程操作下的同步操作
        if (instance==null)
            instance＝new Singleton();
        return instance;
    }
}
// 双重检查 Double-Check locking(DCL)
public class Singleton {
    private static volatile Singleton singleton;
    private Singleton() {}
    public static Singleton getInstance() {
        if (singleton == null) {
            synchronized (Singleton.class) {
                if (singleton == null) {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
// volatile 并发可见性关键字
```

需要注意的是单态模式依然存在局限性，例如分布式EJB下，单例模式几乎已经失去了作用。

### 4. 构建者模式(Builder)

*将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。*

> Builder模式是一步一步创建一个复杂的对象,它允许用户可以只通过指定复杂对象的类型和内容就可以构建它们.用户不知道内部的具体构建细节.Builder模式是非常类似抽象工厂模式,细微的区别大概只有在反复使用中才能体会到.

​	Builder父类和子类主要提供用于对象的表示方法，用另一个类来完成对这些方法的有机组合，这个类的职责就是**‘监工’**。在监工类（Director）中，将父类组合进去，然后调用父类的操作来抽象的实现一件事情，这就是面向接口（抽象）变成的妙处了，当然这个Builder可以使接口也可以是抽象类，在这里我们使用抽象类。

```java
// Builder抽象类
public abstract class Builder {
    public abstract void makeString(String str);
    public abstract void makeTitle(String title);
    public abstract void makeItems(String[] items);
    public abstract void close();
}
// Builder子类1 完成对Html格式内容的表示
public class HtmlBuilder extends Builder {
    private String filename;
    public void makeTitle(String title) {}
    public void makeString(String str) {}
    public void makeItems(String[] items) {}
    public void close() {}
    public String getResult(){
        return filename;
    }
}
// Builder子类2 完成对text格式内容的表示
public class TextBuilder extends Builder {
    private  StringBuffer sb=new StringBuffer();
    public void makeTitle(String title) {}
    public void makeString(String str) {}
    public void makeItems(String[] items) {}
    public void close() {}
    public String getResult(){
        return filename;
    }
}
```

```java
// Director监工类——完成对内容的添加与构建。
public class Director {
    private Builder builder;
    public Director(Builder builder){
        this.builder=builder;
    }
    public void construct(){
        String [] items1=new String[]{"奏国歌","升国旗"};
        String [] items2=new String[]{"观众鼓掌","有序撤离"};
        builder.makeTitle("今日头条");
        builder.makeString("毕业典礼");
        builder.makeItems(items1);
        builder.makeString("典礼结束");
        builder.makeItems(items2);
        builder.close();
    }
}
```

```java
// 外部调用——依次生成Builder类以及Director监工类，以此完成对内容的创建和表示。
public class Main {
    public static void main(String[] args) {
        //String choice="plain";
        String choice="html";
        if(choice=="plain") {
            TextBuilder t=new TextBuilder();
            Director d=new Director(t); d.construct();
            System.out.println(t.getResult());
        }else if(choice=="html") {
            HtmlBuilder html=new HtmlBuilder();
            Director d=new Director(html); d.construct();
            System.out.println(html.getResult());
        }
    }
}
```

如上处理的目的是松耦合的隔离效果，表示层的生成，可以外内容与格式完全不变的情况下完成。例如软件界面风格的切换，即是表示层的切换。隔离的设计好处是复用。通过增加监工增加了对象的创建形式，通过增加Builder子类完成表示层的创建。

### 5. 原型模式(Prototype)

*用原型实例指定创建对象的种类,并且通过拷贝这些原型创建新的对象.*

Prototype模式允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节,工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建。

```java
public abstract class AbstractSpoon implements Cloneable{ 
　　String spoonName; 
　　public void setSpoonName(String spoonName) {this.spoonName = spoonName;}
　　public String getSpoonName() {return this.spoonName;}
　　public Object clone(){
　　　　Object object = null;
　　　　try {
　　　　　　object = super.clone();
　　　　} catch (CloneNotSupportedException exception) {
　　　　　　System.err.println("AbstractSpoon is not Cloneable");
　　　　}
　　　　return object;
　　}
}
```

java语言的特性让设计模式可以更好的实现，直接使用java中的clone()就可以实现该模式。

## 二、结构模式

### 1. 外观模式(Facade)

*为子系统中的一组接口提供一个一致的界面.*

外观模式的目的不是给予子系统添加新的功能接口，而是为了让外部减少与子系统内多个模块的交互，松散耦合，从而让外部能够更简单地使用子系统。

外观模式的本质是：封装交互，简化调用。

```java
// 外部调用一个复杂功能
public class FacadeTest {
    public static void main(String[] args) {
        System.out.println("开始办理行政手续...");
        ApproveFacade af = new ApproveFacade();
        af.wholeApprove();
        System.out.println("行政手续终于办完了");
    }
}
// 该复杂功能包括多个子功能，子功能的执行通过封装来实现，对外仅提供一个接口
class ApproveFacade {
    public ApproveFacade() { }
    public void wholeApprove() {
        new HealthOffice().approve();
        new RevenueOffice().approve();
        new SaicOffice().approve();
    }
}
```

### 2. 代理模式(Proxy)

*为其他对象提供一种代理以控制对这个对象的访问.*

**作用：**

1. 授权机制。
2. 某个客户端不能直接操作到某个对象，但又必须和其互动。

总之原则是,对于开销很大的对象,只有在使用它时才创建,这个原则可以为我们节省很多宝贵的Java内存. 所以,有些人认为Java耗费资源内存,我以为这和程序编制思路也有一定的关系.

```java
// 事件类
interface Things{
    public void th1();
    public void th2();
}
// 事件类执行
class Shopping implements Things{
    @Override
    public void th1(){
        //买毛巾
    }
    @Override
    public void th2(){
        //买衣服
    }
}
// 权限类
class ShopPermissions {
    /**
    * Permission to shop Th1.
    */
    public static final int ShopTh1 = 0;
    ...
}
// 代理类
class ShopProxy implements Things{
    private Shopping people;
    private ShopPermissions permissions;
    
    public Broker(Shopping people, ShopPermissions permissions) {
        this.people = people;
        this.permissions = permissions;
    }
    @Override
    public void Th1() {
        if(this.permissions.ShopTh1 == 1)	//只有当其权限时才可以执行购买
        	this.people.Th1();
    }
    // Th2也是类似情况。通过代理模式来执行实际的操作对象。
}
```

从代码的结构上来看，有点像一堵墙，其他程序只能通过Proxy来对实例对象做交互，即只能和Proxy来交互。

回到开头的作用。1.权限操作，如上示例即为权限部分。2. 不能直接操作，但需要互动。如对一个多线程操作，如果前一个行为未完成的情况下，需要执行该行为，通过代理模式就可以返回该行为的运行状态。例如返回提示，当前忙碌无法执行操作。

**延伸：copy-on-write操作，即使用Proxy代理完成**

​	在多线程操作中，需要对公共数据做读写操作，读操作不改变数据故无太大问题，但写操作时，如果需要做读操作，怎么办？加锁，如果碰到一个连续的读操作，期间需要做写操作时，对目标数据就需要做更新处理，但如果加了锁，则无法进行写操作。

​	此时为了解决锁的问题，提出一种方案，即读写分离操作。即在写入(增/删/改)操作时，拷贝一份数据进行写操作。而读操作继续对原始数据做处理。当写操作完成时更新原始数据。

### 3. 适配器模式(Adapter)

*将两个不兼容的类纠合在一起使用，属于结构型模式,需要有Adaptee(被适配者)和Adaptor(适配器)两个身份*

**在具体的实现过程中，又可以基于其实现层次是类层次还是对象层次，将其分为类适配器和对象适配器。**

```java
public class PegAdapter extends SquarePeg{
    private RoundPeg roundPeg;
    public PegAdapter(RoundPeg peg)(this.roundPeg=peg;)
        public void insert(String str){
        super.insert(str); 	//先继承父类方法，再执行适配接口操作。
        roundPeg.insertIntoHole(str);
    }
}
```

如上示例可见SquarePeg为适配者Adapter，.PegAdapter是Adapter,将Adaptee(被适配者RoundPeg)和Target(目标SquarePeg)进行适配.实际上这是将组合方法(composition)和继承(inheritance)方法综合运用.

使得行为或数据方向从SquarePeg--> roundPeg。完成不兼容接口的整理。

```java
// 下面是新的PegAdapter,叫做two-way adapter:
public class PegAdapter implements IRoundPeg,ISquarePeg{
    private RoundPeg roundPeg;
    private SquarePeg squarePeg;

    // 构造方法
    public PegAdapter(RoundPeg peg){this.roundPeg=peg;}
    // 构造方法
    public PegAdapter(SquarePeg peg)(this.squarePeg=peg;)
    	public void insert(String str){ 
    	roundPeg.insertIntoHole(str);
	}
}
```

**另解：适配器模式是指，定义一个类，将一个已经存在的类，转换成目标接口所期望的行为形式。**

```java
class UserAdapter extends UserInfo implements UserInterface {
    @Override
    public String getName() {
        return (String) super.getUserBaseInfo().get("name");
    }
    @Override
    public String getTelNumber() {
        return (String) super.getUserBaseInfo().get("telNumber");
    }
}
/*
UserInterface：目标角色——目标接口，系统所期待实现的目标；
UserInfo：源角色——当前已经存在的原有的实现类，即将被适配的类；
UserAdapter：适配器角色——将原有实现装换为目标接口的实现。
*/
```

**适配器模式是指定义一个适配器类，将一个已经存在的类，转换成目标接口所期望的行为形式。同时，一般来说，基于更多的推荐使用组合而不是继承，因此，对象适配器可能使用更多。**

### 4. 组合模式(Composite)

*将对象以树形结构组织起来,以达成 “部分－整体” 的层次结构，使得客户端对单个对象和组合对象的使用具有一致性.*

​	组合模式中当然在组合对象中含有被组合对象的引用，只是不同的是，组合模式在概念上更加严格，通常是指引用的被组合对象类型就是组合对象的类型。如此一来，使得组合对象和被组合对象处理起来具有一致性。当然，前提是组合被对象和被组合对象在本身的概念层次上具有此一致性。

```java
class TreeNode {
    private String name;
    private TreeNode parent;
    private Vector<TreeNode> children = new Vector<TreeNode>();
    
    public TreeNode() { }
    public TreeNode(String name) { this.name = name; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public TreeNode getParent() { return parent; }
    public void setParent(TreeNode parent) { this.parent = parent; }
    public Vector<TreeNode> getChildren() { return children; }
    public void setChildren(Vector<TreeNode> children) { this.children = children; }
    // 添加孩子结点
    public void addChild(TreeNode child) { children.add(child); }
    // 删除子结点
    public void removeChild(TreeNode child) { children.remove(child); }
    // 获取子结点
    public Enumeration<TreeNode> getChileren() { return children.elements(); }
}
```

如上结构，对应的业务处理为，节点的增删改业务。比如论坛中的回复就位树形结构，增删改操作即可在外部调用组合实现。

```java
//使用List存放，使用java内置的next函数来访问
abstract class CompositeEquipment extends Equipment
{
　　private int i=0; 
　　//定义一个Vector 用来存放'儿子'
　　private Lsit equipment=new ArrayList();
　　public CompositeEquipment(String name) { super(name); }
　　public boolean add(Equipment equipment) { this.equipment.add(equipment);return true; }

    public double netPrice() 
    {
        double netPrice=0.;
        Iterator iter=equipment.iterator();
        for(iter.hasNext())
        	netPrice += ((Equipment)iter.next()).netPrice();
        return netPrice;
    }
    public double discountPrice() 
    {
        double discountPrice=0.;
        Iterator iter=equipment.iterator();
        for(iter.hasNext())
        	discountPrice += ((Equipment)iter.next()).discountPrice();
        return discountPrice;
    }

	//注意这里，这里就提供用于访问自己组合体内的部件方法。
	//上面dIsk 之所以没有，是因为Disk是个单独(Primitive)的元素.
	public Iterator iter() { return equipment.iterator(); }
    //重载Iterator方法
    public boolean hasNext() { return i<equipment.size(); }
    //重载Iterator方法
    public Object next()
    {
        if(hasNext())
        	return equipment.elementAt(i++);
        else 
        	throw new NoSuchElementException();
    }
}
```

```mermaid
graph TD
A[CommodityComposite];B[手机];B1[A手机];B11[3月9折];B2[B手机];B21[3-4月9.5折];B3[C手机]
C[电脑];C1[A电脑];C11[A1型号];C111[A1型号10月8折];C12[A2型号];C2[B电脑]
A-->B;A-->C;
B-->B1;B1-->B11;B-->B2;B2-->B21;B-->B3
C-->C1;C-->C2;C1-->C11;C11-->C111;C1-->C12;
```

例如：如上树形结构，每一个节点均包含价格。此时如果外部程序调用3月份的手机价格如何。则会依次遍历手机分支下的价格，如果存在折扣，则计算折扣，否则不计算。

如此就能对一组存在树形结构的对象，做统一处理，而不用分别遍历。

**形式结构与逻辑结构相统一。便于业务实现。**

### 5. 装饰器模式(Decorator)

*动态给一个对象添加一些额外的职责,就象在墙上刷油漆.使用Decorator模式相比用生成子类方式达到功能的扩充显得更为灵活.*

我们通常可以使用继承来实现功能的拓展,如果这些需要拓展的功能的种类很繁多,那么势必生成很多子类,增加系统的复杂性,同时,使用继承实现功能拓展,我们必须可预见这些拓展功能,这些功能是编译时就确定了,是静态的.

使用Decorator的理由是:这些功能需要由用户动态决定加入的方式和时机.Decorator提供了"即插即用"的方法,在运行期间决定何时增加何种功能.

```java
// 首先建立一个接口类
public interface Work { 
　　public void insert();
}
// 创建需求子类
public class SquarePeg implements Work{
　　public void insert(){
　　　　System.out.println("方形桩插入");
　　}
}
// 创建适配器
public class Decorator implements Work{

　　private Work work;
　　//额外增加的功能被打包在这个List中
　　private ArrayList others = new ArrayList();

　　//在构造器中使用组合new方式,引入Work对象;
　　public Decorator(Work work) {
　　　　this.work=work;
　　　　others.add("挖坑");
　　　　others.add("钉木板");
　　}
　　public void insert() {
　　　　newMethod();
　　}
　　//在新方法中,我们在insert之前增加其他方法,这里次序先后是用户灵活指定的 　　 
　　public void newMethod() {
　　　　otherMethod();
　　　　work.insert();
　　} 
　　public void otherMethod() {
　　　　ListIterator listIterator = others.listIterator();
　　　　while (listIterator.hasNext()) {
　　　　　　System.out.println(((String)(listIterator.next())) + " 正在进行");
　　　　}
　　} 
}
```

```java
// 实际调用如下
Work squarePeg = new SquarePeg(); 
Work decorator = new Decorator(squarePeg);
decorator.insert();
```

基于实例，可见此处的装饰器模式即为在基类work的基础上衍生出很多的相似类，然后基于这些相似类完成适配器的统一类。例如：工作总结，每个人每个部门的工作均不同，但都可以做一个统一的工作总结适配器类。只需要把每个人每个部门的对象装载其中即可。(假装懂了，未实践仅嘴上说说)

### 6. 桥接模式(Bridge)

*将抽象和行为划分开来,各自独立,但能动态的结合。*

在面向对象设计的基本概念中，对象这个概念实际是由属性和行为两个部分组成的，属性我们可以认为是一种静止的，是一种抽象，一般情况下，行为是包含在一个对象中，但是，在有的情况下，我们需要将这些行为也进行归类，形成一个总的行为接口，这就是桥模式的用处。

**例：**咖啡分为：大杯中杯两种，同时又分为加奶不加奶，如此分为四种。具体而言，大杯中杯为属性，加不加奶为行为，因此此处可以把抽象与行为划分开来。因为加奶的行为之外还有加糖，如此行为本身就有很多衍生和扩展。如需结构化代码就需使用桥接模式。

```java
// 先定义两个抽象类
public abstract class CoffeeImp { // 行为集合
    public abstract void pourCoffeeImp();	// 行为
}
public abstract class Coffee { // 对象的抽象类
    CoffeeImp coffeeImp;		// 对象的行为
    public void setCoffeeImp() {		//单例模式下达到行为与对象的统一
        this.CoffeeImp = CoffeeImpSingleton.getTheCoffeImp();
    }
    public CoffeeImp getCoffeeImp() {return this.CoffeeImp;}
    public abstract void pourCoffee();	// 抽象与行为的叠加接口
}
```

```java
// 基于如上两个接口我们轻易可知两种基于Coffee的对象，分别为中杯和大杯
public class MediumCoffee extends Coffee {
    public MediumCoffee() {setCoffeeImp();}
    public void pourCoffee() {
        CoffeeImp coffeeImp = this.getCoffeeImp();
        for (int i = 0; i < 2; i++) { //我们以重复次数来说明是冲中杯还是大杯 ,重复2次是中杯
            coffeeImp.pourCoffeeImp(); // 此处为抽象对象的行为
        }
    }
}
public class SuperSizeCoffee extends Coffee {
    public SuperSizeCoffee() {setCoffeeImp();}
    public void pourCoffee() {
        CoffeeImp coffeeImp = this.getCoffeeImp();
        for (int i = 0; i < 5; i++) { //我们以重复次数来说明是冲中杯还是大杯 ,重复5次是大杯
            coffeeImp.pourCoffeeImp();	// 此处为抽象对象的行为
        }
    }
}
```

```java
// 基于行为的实现类，分别为加奶和不加奶
public class MilkCoffeeImp extends CoffeeImp {
    MilkCoffeeImp() {}
    public void pourCoffeeImp() {
        System.out.println("加了美味的牛奶");
    }
}
public class FragrantCoffeeImp extends CoffeeImp {
    FragrantCoffeeImp() {}
    public void pourCoffeeImp() {
        System.out.println("什么也没加,清香");
    }
}
```

```java
// 如上我们就获取抽象类以及相关行为类，现创建单态模式的对象类
public class CoffeeImpSingleton {
    private static CoffeeImp coffeeImp;
    public CoffeeImpSingleton(CoffeeImp coffeeImpIn) { this.coffeeImp = coffeeImpIn; }
    public static CoffeeImp getTheCoffeeImp() { return coffeeImp; }
}
// 外部使用如下：
//拿出牛奶
CoffeeImpSingleton coffeeImpSingleton = new CoffeeImpSingleton(new MilkCoffeeImp());

//中杯加奶
MediumCoffee mediumCoffee = new MediumCoffee();
mediumCoffee.pourCoffee();

//大杯加奶
SuperSizeCoffee superSizeCoffee = new SuperSizeCoffee();
superSizeCoffee.pourCoffee();
```

注意: Bridge模式的执行类如CoffeeImp和Coffee是一对一的关系, 正确创建CoffeeImp是该模式的关键。

### 7. 享元模式(Flyweight)

*避免大量拥有相同内容的小类的开销(如耗费内存),使大家共享一个类(元类).*

当系统中可能具有多个相同的对象时，对于具有相同的内容的对象可以实现对象的共享，即共享池，以此避免不必要的相同对象的创建以减少系统内存的开销。称之为享元模式。对于定义中的相同的对象，相同一词如何理解？首先我们需要解释下享元模式中的两个概念：内蕴状态和外蕴状态。

内蕴状态：享元对象内部的可以以此来作为区分是否是同一个对象的依据的属性。内蕴状态不随着外部环境的变化而变化。

外蕴模式：虽然也是享元对象的属性，但可以随着外部环境的变换而变化，同一享元对象在不同的地方其内部的外蕴状态可能不同。

```java
interface Flyweight{
    // 用于改变外蕴状态 
    public void changeStat(String exState);
}
class ConcreteFlyweight implements Flyweight {
    //内蕴状态
    private String innerState;
    // 外蕴状态 
    private String exState;

    public ConcreteFlyweight(String innerState) {
        this.innerState = innerState;
    }
    @Override
    public void changeStat(String exState) {
        this.exState = exState;
    }
}
```

使用工厂模式管理公共数据

```java
class FlyweightFactory {
    private static Map<String, Flyweight> flyweightMap = new HashMap<String, Flyweight>();
    public static Flyweight getFlyweight(String innerState) {
        Flyweight flyweight = flyweightMap.get(innerState);
        if (flyweight == null) {
            flyweight = new ConcreteFlyweight(innerState);
            flyweightMap.put(innerState, flyweight);
        }
        return flyweight;
    }

}
```

```java
// 实际使用如下
public class FlyweightTest {
    public static void main(String[] args) {
        Flyweight a = FlyweightFactory.getFlyweight("A"); a.changeStat("first-A");
        Flyweight b = FlyweightFactory.getFlyweight("B"); b.changeStat("first-B");

        Flyweight aa = FlyweightFactory.getFlyweight("A"); aa.changeStat("second-A");
        Flyweight bb = FlyweightFactory.getFlyweight("B"); bb.changeStat("second-B");

        System.out.println(a == aa);  // true
        System.out.println(b == bb);  // true
    }
}
```

## 三、行为模式

### 3.1 模板模式(Template)

*定义一个操作中算法的骨架,将一些步骤的执行延迟到其子类中.*

```java
public abstract class Benchmark {
    // 下面操作是我们希望在子类中完成
    public abstract void benchmark();
    // 重复执行benchmark次数
    public final long repeat (int count) {
        if (count <= 0)
            return 0;
        else {
            long startTime = System.currentTimeMillis();
            for (int i = 0; i < count; i++)
                benchmark();
            long stopTime = System.currentTimeMillis();
            return stopTime - startTime;
        }
    }
}
public class MethodBenchmark extends Benchmark {
　　// 真正定义benchmark内容
　　public void benchmark() {
　　　　for (int i = 0; i < Integer.MAX_VALUE; i++){
　　　 　　System.out.printtln("i="+i);　 　　
　　　 }
　　}
}
```

```java
//实际使用如下
Benchmark operation = new MethodBenchmark();
long duration = operation.repeat(Integer.parseInt(args[0].trim()));	// 设定操作次数
System.out.println("The operation took " + duration + " milliseconds");
```

一般而言子类都是对父类的延伸，功能的扩展。父类多为抽象类或者基础类。但模板模式却逆向使用，父类做实操功能，部分功能交给不同的子类，以此来实现模板效果。

### 3.2 备忘录模式(Memento)

*memento是一个保存另外一个对象内部状态拷贝的对象.这样以后就可以将该对象恢复到原先保存的状态.*

实例应用：注册过程中，提交后验证发现部分项填写异常，此时需要用备忘录模式记录已经填写的信息，用以避免重新填写正确信息。

```java
// Memento类
public class Memento {
    private int SaveNum;
    Memento(int SaveNum) {
        this.SaveNum = SaveNum;
    }
    public int getNum() { return SaveNum; }
}
```

```java
// Gamer类
public class Gamer {
    private int Num;
    public Gamer(int Num) { this.Num = Num; }
	//获取当前数值
    public int getNum() { return Num; }
    public void bet() {
        // 获取骰子数值
        this.Num = random.nextInt(100)
    }
	//创建备忘录	@return 备忘录对象
    public Memento createMemento() { return new Memento(Num); }
	//撤销到指定备忘	@param memento 备忘录对象
    public void restoreMemento(Memento memento) {
        this.Num = memento.getNum();
    }
    @Override
    public String toString() {
        return "Gamer{ Num=" + money + "}";
    }
}
```

```java
// 测试类
public class MementoTest {
    @Test
    public void testMemento() {
        Gamer gamer = new Gamer(0);
        Memento memento = gamer.createMemento();
        for (int i = 0; i < 20; i++) {
            System.out.println("==== " + i);
            System.out.println("当前状态：" + gamer);
            // 投掷骰子
            gamer.bet();
            // 如何处理memento
            if (gamer.Num() > 90) {
                System.out.println("获取到理想数值。");
                memento = gamer.createMemento();
                break;
            } else {
                System.out.println("未获取到理想数值。保存状态重新来过。");
                gamer.restoreMemento(memento);
            }
        }
    }
}
```

类似于泛华对象，取部分重要数据成一对象作为记录暂时保存，当需要回到原有状态时，则通过加载接口即可实现。

**备忘录模式中的角色：1. 生成者(Originator)——例中Gamer角色。2. 纪念品(Memento)`Memento`角色会将`Originator`角色的内部信息整合在一起。在`Memento`角色中虽然保存了`Originator`角色的信息，但它不会向外部公开这些信息。3. 负责人(Caretaker)**

![类图](E:\GitHubCode\LearnSameBaseKnowlage\MarkdownTxt\mdPic\20170413104417702.png)

### 3.3 观察者模式(Observer)

*定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。*

其功用以及实现方式，即为**类似回调**这样的行为，把一个响应函数或类或对象**关联**到另一个类中，当另一个类出现某种变化时，则执行这个回调对象。以此实现该模式

```java
/* Java的API还为为我们提供现成的Observer接口Java.util.Observer.我们只要直接使用它就可以.
 * 我们必须extends Java.util.Observer才能真正使用它:
 *	1.提供Add/Delete observer的方法;
 *	2.提供通知(notisfy) 所有observer的方法;
 * 产品类 可供Jsp直接使用UseBean调用 该类主要执行产品数据库插入 更新
 */ 
public class product extends Observable{
    private String name;
    private float price;
    public String getName(){ return name;}
    public void setName(String name){ 
        this.name=name;
        //设置变化点 
        setChanged();
        notifyObservers(name);
    }
    public float getPrice() { return price;}
    public void setPrice(float price) {
        this.price=price;
        //设置变化点
        setChanged();
        notifyObservers(new Float(price));
    }
    //以下可以是数据库更新 插入命令.
    public void saveToDb(){
        .....................
    }
}
```

```java
// 观察者NameObserver主要用来对产品名称(name)进行观察的
public class NameObserver implements Observer {
　　private String name=null;
　　public void update(Observable obj,Object arg) {
　　　　if (arg instanceof String) {
　　　　 name=(String)arg;
　　　　}
　　}
}
// 观察者PriceObserver主要用来对产品价格(price)进行观察的
public class PriceObserver implements Observer {
　　private float price=0;
　　public void update(Observable obj,Object arg) {
　　　　if (arg instanceof Float) {
　　　　 price=((Float)arg).floatValue();
　　　　}
　　}
}
```

```java
// 实际使用
Product product=new Product();
NameObserver nameobs=new NameObserver();
PriceObserver priceobs=new PriceObserver();

//加入观察者
product.addObserver(nameobs);
product.addObserver(priceobs);

product.setName("橘子红了");
product.setPrice(9.22f);
```

A->B的通知，可以用观察者模式。衍生一下自通知，变化量及变化方式与执行的分离，此时可以通过观察者模式实现变化。

```java
// 观察者相关类
interface Observer {
    public void update();
}
class ObserverA implements Observer {
    @Override
    public void update() { System.out.println("ObserverA has received!"); }
}
class ObserverB implements Observer {
    @Override
    public void update() { System.out.println("ObserverB has received!"); }
}
```

```java
// 被观察者抽象类及子类
abstract class Observable {

    private Vector<Observer> vector = new Vector<Observer>();

    public void add(Observer observer) { vector.add(observer); }
    public void del(Observer observer) { vector.remove(observer); }
    public void notifyObservers() {
        Enumeration<Observer> enumo = vector.elements();
        while (enumo.hasMoreElements()) {
            enumo.nextElement().update();
        }
    }
    public void operation() {}
}
class ConcretObservable extends Observable{
    @Override
    public void operation() {  System.out.println("update self!"); notifyObservers(); }
}
```

```java
// 外部调用
public class ObserverTest {  
    public static void main(String[] args) {  
        Observable sub = new ConcretObservable();  
        sub.add(new ObserverA());  
        sub.add(new ObserverB());  
        sub.operation();  
    }
}
```

### 3.4 职责链模式(Chain of Responsibility)

*Chain of Responsibility(CoR) 是用一系列类(classes)试图处理一个请求request,这些类之间是一个松散的耦合,唯一共同点是在他们之间传递request. 也就是说，来了一个请求，A类先处理，如果没有处理，就传递到B类处理，如果没有处理，就传递到C类处理，就这样象一个链条(chain)一样传递下去。*

```java
// 接口Handler的代码如下：
public interface Handler{
    public void handleRequest(Request request);
}
// Request类的定义:
public class Request{
    private String type;
    public Request(String type){this.type=type;}
    public String getType(){return type;}
    public void execute(){
        //request真正具体行为代码
    }
}
//那么Handler实现代码如下：
public class ConcreteHandler implements Handler{
　　private Handler successor;
　　public ConcreteHandler(Handler successor){
　　　　this.successor=successor;
　　}
　　public void handleRequest(Request request){
　　　　if (request instanceof HelpRequest){	//意在表达当前请求是否为帮助请求
　　　　　　request.execute();	//这里是处理Help的具体代码
　　　　}else if (request instanceof PrintRequst){ //意在表达当前请求是否为打印请求
　　　　　　request.execute();
　　　　}else
　　　　　　//传递到下一个
　　　　　　successor.handle(request);
　　　　}
　　}
}
//A instanceof B, 关键字的含义是，A(对象)与B(类)的关系如果为父类，实现类，自身类时则返回True
```

**CoR的优缺点：**
因为无法预知来自外界（客户端）的请求是属于哪种类型，每个类如果碰到它不能处理的请求只要放弃就可以。

缺点是效率低，因为一个请求的完成可能要遍历到最后才可能完成，当然也可以用树的概念优化。 在Java AWT1.0中，对于鼠标按键事情的处理就是使用CoR,到Java.1.1以后，就使用Observer代替CoR

扩展性差，因为在CoR中，一定要有一个统一的接口Handler.局限性就在这里。

### 3.5 命令模式(Command)

*将来自客户端的请求传入一个对象，无需了解这个请求激活的 动作或有关接受这个请求的处理细节。*

解耦了发送者和接受者之间联系。 发送者调用一个操作，接受者接受请求执行相应的动作，因为使用Command模式解耦，发送者无需知道接受者任何接口。显然这样做的好处是符合封装的特性,降低耦合度,Command是将对行为进行封装的典型模式,Factory是将创建进行封装的模式,

```java
// Command抽象类及各种实现类
public interface Command {
    public abstract void execute ();
}
public class Engineer implements Command {
    public void execute( ) { /*do Engineer's command*/ }
}
public class Programmer implements Command {
    public void execute( ) { /*do programmer's command*/ }
}
public class Politician implements Command {
    public void execute( ) { /*do Politician's command*/ }
}
//命令整合类
public class producer{
    public static List produceRequests() {
        List queue = new ArrayList();
        queue.add(new DomesticEngineer());
        queue.add(new Politician());
        queue.add(new Programmer());
        return queue; 
    }
}
```

```java
// 调用类
List queue = Producer.produceRequests();
for(Iterator it = queue.iterator();it.hasNext();) {
    //客户端直接调用execute方法，无需知道被调用者的其它更多类的方法名。
    ((Command)it.next()).execute();
}
```

由此可见,调用者基本只和接口打交道,不合具体实现交互,这也体现了一个原则,面向接口编程,这样,以后增加第四个具体命令时,就不必修改调用者TestCommand中的代码了.

理解了上面的代码的核心原理,在使用中,就应该各人有自己方法了,特别是在**如何分离调用者和具体命令上**,有很多实现方法,上面的代码是使用"从List过一遍"的做法.这种做法只是为了演示.

**延伸：undo/redo**撤销和回复功能。该功能的实现有两种思路： 记录数据和记录操作。

记录数据可见备忘录模式，把备忘录整理成一个List格式，以时间或者事件触发的方式记录下每一步的数据。此法以空间换时间，快速可靠。但缺点就是当数据量大的时候占用太多内存，比如视频图片等数据。

记录操作在命令模式的基础上做一个List记录每一个操作，而在命令实现中加入回复操作的方法。以此就形成了undo和redo的功能，不用记录数据的原因是，每一步回复和撤销都是在当前数据下执行或逆执行，以此完成该功能。该做法是以时间换空间，例如1000条数据，仅对一条数据了更新，此时如用记录数据的方式则使得重复数据过多。

### 3.6 状态模式(State)

*不同的状态,不同的行为;或者说,每个状态有着相应的行为.*

































