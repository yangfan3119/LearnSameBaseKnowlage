### Double类型理解和转化

#### 1. 概述

​	因项目需求。需要对double型数据做串口传输，因此如何把double型数据转为8个字节的byte型数据，就尤为关键了。按照一般的行为思考，为了保证精度，可以对8字节的数据做整形转换在除以10^n，以此来确定具体的精度。但这显然对于计算机而言加大了运算量。

​	故，详细的了解double类型在计算机中的存储已经是非常的必要了。

​	Double类型遵循**IEEE754标准**

![IEEE754标准](E:\GitHubCode\LearnSameBaseKnowlage\MarkdownTxt\mdPic\897393-20181009100936506-2134173847.png)

#### 2. double型详解

**S EEEE EEEE EEE DDDD DDDD DDDD DDDD DDDD DDDD DDDD DDDD DDDD DDDD DDDD DDDD DDDD**

> S	-----	符号位：0为正数，1为负数
>
> EEEE EEEE EEE ------ 指数位：数据位的小数点偏移数，因存在正负数的问题，因此2^10-1为0指数的值
>
> DDD{n=52}	------ 数据位：默认为二进制数据，**且数据位默认缺省第一个1值，因此转化时需要补位**

例如：

123.45	

=》bin(123.45)=bin(123)+bin(0.45)

bin(123)转二进制则*除二取余*，得**0b111 1011**

bin(0.45)转二进制则*乘二区整*，得**0b0111001100110011001100110011001100110011001100**

则整体有：**bin(123.45) = 0b 111 1011. 0111001100110011001100110011001100110011001100**共计53位

指数偏移为：+6 （变为：0b 1.11 1011 0111 0011 0011 0011...） = 1023+6=1029

符号位为：0

整合后有：

0 1000 0000 101 1110 1101 1100 1100 1100  1100  1100  1100  1100  1100  1100  1100 1100(需进位)

转为十六进制为： hex = 0x 40 5E DC CC CC CC CC CD

#### 3. 代码实现

​	代码实现分为两种，一种为根据如上的转化算法做转化，另一种根据*union*共用体的方式实现。

方法一：转化值double d为8个字节数据。

  		1. 取符号位，d>0为0，<0为1
  		2. d的整数部分和小数部分分别转化为二进制数值
  		3. 算出指数位
  		4. 整合排序1+11+52的数据逻辑
  		5. 8位整理分段

方法二：转化值double d为8个字节的数据

```c
typedef union{
	double d64;
	u8 v[9];
}_Double64;
_Double64 dx;
dx.d64 = d
# 此时8个字节的数据分别为v[0]---v[7],其中[0]为低位，[7]为高位
```

如上方法为double转byte[8]方法，逆向即为byte[8]到double的方法。此处不多说

### Float类型的理解和转化

#### 说明：

​	作为双精度延伸的另一个浮点类型数据Float，它只有double的一半字节，但转化的原理和double完全一样只是数据位不同而已。参考double中的图可知32位的Float型数据符号位、指数位、数据位分别所占的比例为：1+8+23

### 延伸

#### 1. 精度说明

​	显然我们知道了浮点型数据的逻辑结构位，因此可知其精度为：

​	双精度Double数据位长度为：
$$
Double64数据长度为52位,则有效数字为：2^{52}=4.50*10^{15}=16-15个有效数字
$$
​	单精度Float数据位长度为：
$$
Float32数据长度为23位，则有效数字为：2^{23} =8.38886*10^{7} = 7-6个有效数字
$$








